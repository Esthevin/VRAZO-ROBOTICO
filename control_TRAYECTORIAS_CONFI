#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from std_msgs.msg import Float32, Bool
import math
import threading
import time

GRIPPER_ABIERTO = (110-180)*math.pi/180
GRIPPER_CERRADO = (135-180)*math.pi/180
GRIPPER_HOME = 0*math.pi/180

class Trayectorias(Node):

    def __init__(self):
        super().__init__("trayectorias_p")

        # Publicadores
        self.pub_pos = self.create_publisher(Point, "cmd_xyz_position", 10)
        self.pub_gripper = self.create_publisher(Float32, "cmd_gripper", 10)

        # Subscriber para confirmaci√≥n
        self.objetivo_alcanzado = False
        self.objetivo_lock = threading.Lock()
        
        self.create_subscription(
            Bool, 
            "objetivo_alcanzado", 
            self.objetivo_callback, 
            10
        )

        # Subscriber para sensor de presencia
        self.presencia_detectada = False
        self.secuencia_activada = False
        self.create_subscription(
            Bool,
            "presencia_detectada",
            self.presencia_callback,
            10
        )

        self.get_logger().info("=== Nodo de Trayectorias Inicializado ===")
        self.get_logger().info("üîÑ Esperando se√±al de presencia para activar secuencia...")

    def presencia_callback(self, msg: Bool):
        """Callback que recibe se√±al del sensor de presencia"""
        if msg.data and not self.presencia_detectada:
            self.presencia_detectada = True
            self.get_logger().info("üöÄ SE√ëAL DE PRESENCIA DETECTADA - Activando secuencia...")
            # Iniciar la secuencia autom√°ticamente en un hilo separado
            if not self.secuencia_activada:
                self.secuencia_activada = True
                threading.Thread(target=self.ejecutar_secuencia_automatica, daemon=True).start()
        elif not msg.data and self.presencia_detectada:
            self.presencia_detectada = False
            self.get_logger().info("‚úÖ Presencia desaparecida")

    def ejecutar_secuencia_automatica(self):
        """Ejecuta la secuencia cuando se detecta presencia"""
        try:
            self.get_logger().info("üé¨ Iniciando secuencia autom√°tica por presencia...")
            self.ejecutar_secuencia_4()
        except Exception as e:
            self.get_logger().error(f"‚ùå Error en secuencia autom√°tica: {str(e)}")
        finally:
            self.secuencia_activada = False
            self.presencia_detectada = False
            self.get_logger().info("üîÑ Listo para nueva detecci√≥n de presencia")

    def ejecutar_secuencia_4(self):
        """Versi√≥n de secuencia_4 que funciona como m√©todo de la clase"""
        # Definir posiciones clave
        HOME = (-0.87, -0.1014, 2.9964)
        OBJETO = (-1.0, -2.0, 1.5)
        DESTINO = (1.1, -1.5, 2.6)
        PRE_AGARRE = (-1.0, -2.0, 2.0)
        PRE_DESTINO = (1.0, -1.4, 2.3)
        LEVANTAR_AGARRE = (-0.0, -0.87, 2.99)
        LEVANTAR_DESTINO = (0.7, -0.87, 2.5)
        
        try:
            # 1. Ir a HOME
            self.mover_a(*HOME)
            # Abrir gripper
            if not self.set_gripper(GRIPPER_ABIERTO):
                self.get_logger().error("‚ùå Fallo al abrir gripper")
                return
            # Moverse sobre el objeto
            if not self.mover_a(*PRE_AGARRE):
                self.get_logger().error("‚ùå Fallo en aproximaci√≥n")
                return
            
            # 4. Bajar al objeto
            if not self.mover_a(*OBJETO):
                self.get_logger().error("‚ùå Fallo al descender")
                return
            
            # 5. Cerrar gripper (agarrar)
            if not self.set_gripper(GRIPPER_CERRADO):
                self.get_logger().error("‚ùå Fallo al cerrar gripper")
                return
            
            # 6. Levantar objeto
            if not self.mover_a(*PRE_AGARRE):
                self.get_logger().error("‚ùå Fallo al levantar")
                return
            
            # levar a zona segura
            if not self.mover_a(*LEVANTAR_AGARRE):
                self.get_logger().error("‚ùå Fallo al levantar a zona segura")
                return
            # levar a zona segura
            if not self.mover_a(*LEVANTAR_DESTINO):
                self.get_logger().error("‚ùå Fallo al levantar a zona segura")
                return

            # 7. Moverse sobre destino
            if not self.mover_a(*PRE_DESTINO):
                self.get_logger().error("‚ùå Fallo en transporte")
                return
            
            # 8. Bajar al destino
            if not self.mover_a(*DESTINO):
                self.get_logger().error("‚ùå Fallo al descender")
                return
            
            # 9. Abrir gripper (soltar)
            if not self.set_gripper(GRIPPER_ABIERTO):
                self.get_logger().error("‚ùå Fallo al soltar")
                return
            
            # 10. Levantar
            if not self.mover_a(PRE_DESTINO[0]-0, PRE_DESTINO[1]+0, PRE_DESTINO[2]-0):
                self.get_logger().error("‚ùå Fallo al retirarse")
                return
            
            self.set_gripper(GRIPPER_HOME)
            # 11. Volver a HOME
            if not self.mover_a(*HOME):
                self.get_logger().error("‚ùå Fallo al regresar")
                return

            self.get_logger().info("=" * 50)
            self.get_logger().info("üéâ ¬°SECUENCIA COMPLETADA EXITOSAMENTE! üéâ")
            self.get_logger().info("=" * 50)

        except Exception as e:
            self.get_logger().error(f"‚ùå Error en secuencia: {str(e)}")
            raise

    def objetivo_callback(self, msg: Bool):
        """Callback que recibe confirmaci√≥n cuando se alcanza el objetivo"""
        with self.objetivo_lock:
            if msg.data:
                self.objetivo_alcanzado = True
                if not hasattr(self, '_last_estado') or not self._last_estado:
                    self.get_logger().info("‚úÖ Confirmaci√≥n recibida")
                self._last_estado = True
            else:
                self._last_estado = False

    def esperar_objetivo(self, timeout=10.0):
        """Espera hasta que el objetivo sea alcanzado o timeout"""
        tiempo_inicio = self.get_clock().now()
        
        with self.objetivo_lock:
            self.objetivo_alcanzado = False
        
        self.get_logger().info(f"‚è≥ Esperando confirmaci√≥n (max {timeout}s)...")
        
        contador = 0
        start_time = time.time()
        
        while rclpy.ok():
            with self.objetivo_lock:
                if self.objetivo_alcanzado:
                    self.get_logger().info("‚úì Movimiento completado")
                    return True
            
            # Verificar timeout
            elapsed_time = time.time() - start_time
            
            # Log de progreso cada 2 segundos
            if contador % 20 == 0 and contador > 0:
                self.get_logger().info(f"‚è±Ô∏è Esperando... {elapsed_time:.1f}s / {timeout}s")
            
            if elapsed_time > timeout:
                self.get_logger().error(f"‚ùå TIMEOUT ({timeout}s) - El robot no confirm√≥ el objetivo")
                return False
            
            contador += 1
            time.sleep(0.1)  # Peque√±a pausa para no saturar
        
        return False

    def mover_a(self, x, y, z, timeout=15.0):
        """
        Mueve el robot a una posici√≥n y espera confirmaci√≥n
        
        Args:
            x, y, z: Coordenadas destino
            timeout: Tiempo m√°ximo de espera en segundos
        
        Returns:
            True si alcanz√≥ el objetivo, False si timeout
        """
        msg = Point()
        msg.x, msg.y, msg.z = x, y, z
        self.pub_pos.publish(msg)
        self.get_logger().info(f"üìç Comando: Mover a [{x:.3f}, {y:.3f}, {z:.3f}]")
        
        return self.esperar_objetivo(timeout)

    def set_gripper(self, angle, timeout=8.0):
        """
        Ajusta el gripper y espera confirmaci√≥n
        
        Args:
            angle: √Ångulo objetivo en radianes
            timeout: Tiempo m√°ximo de espera
        
        Returns:
            True si alcanz√≥ el objetivo, False si timeout
        """
        msg = Float32()
        msg.data = float(angle)
        self.pub_gripper.publish(msg)
        
        estado = "ABIERTO" if angle < GRIPPER_CERRADO else "CERRADO"
        self.get_logger().info(f"‚úã Comando: Gripper ‚Üí {estado} ({math.degrees(angle):.1f}¬∞)")
        
        return self.esperar_objetivo(timeout)


# Mantener las funciones originales para uso manual si es necesario
def secuencia_1():
    rclpy.init()
    node = Trayectorias()
    rclpy.spin_once(node, timeout_sec=0.1)  # Procesar callbacks pendientes
    
    # Definir posiciones clave
    HOME = (-0.87, -0.1014, 2.9964)
    OBJETO = (-1.0, -2.0, 1.5)
    DESTINO = (1.5, -2.0, 1.5)
    PRE_AGARRE = (-1.0, -2.0, 2.0)
    PRE_DESTINO = (1.5, -2.0, 2.0)

    node.get_logger().info("üöÄ Iniciando secuencia de pick and place...")
    
    try:
        # 1. Ir a HOME
        node.get_logger().info("--- PASO 1: Ir a HOME ---")
        if not node.mover_a(*HOME):
            node.get_logger().error("‚ùå Fallo al ir a HOME")
            return
        if not node.set_gripper(GRIPPER_HOME):
            node.get_logger().error("‚ùå Fallo al abrir gripper")
            return
        
        # 2. Abrir gripper
        node.get_logger().info("--- PASO 2: Abrir Gripper ---")
        if not node.set_gripper(GRIPPER_ABIERTO):
            node.get_logger().error("‚ùå Fallo al abrir gripper")
            return
        
        # 3. Moverse sobre el objeto
        node.get_logger().info("--- PASO 3: Aproximaci√≥n al objeto ---")
        if not node.mover_a(*PRE_AGARRE):
            node.get_logger().error("‚ùå Fallo en aproximaci√≥n")
            return
        
        # 4. Bajar al objeto
        node.get_logger().info("--- PASO 4: Descender al objeto ---")
        if not node.mover_a(*OBJETO):
            node.get_logger().error("‚ùå Fallo al descender")
            return
        
        # 5. Cerrar gripper (agarrar)
        node.get_logger().info("--- PASO 5: Agarrar objeto ---")
        if not node.set_gripper(GRIPPER_CERRADO):
            node.get_logger().error("‚ùå Fallo al cerrar gripper")
            return
        
        # 6. Levantar objeto
        node.get_logger().info("--- PASO 6: Levantar objeto ---")
        if not node.mover_a(*PRE_AGARRE):
            node.get_logger().error("‚ùå Fallo al levantar")
            return
        
        # 7. Moverse sobre destino
        node.get_logger().info("--- PASO 7: Transportar al destino ---")
        if not node.mover_a(*PRE_DESTINO):
            node.get_logger().error("‚ùå Fallo en transporte")
            return
        
        # 8. Bajar al destino
        node.get_logger().info("--- PASO 8: Descender al destino ---")
        if not node.mover_a(*DESTINO):
            node.get_logger().error("‚ùå Fallo al descender")
            return
        
        # 9. Abrir gripper (soltar)
        node.get_logger().info("--- PASO 9: Soltar objeto ---")
        if not node.set_gripper(GRIPPER_ABIERTO):
            node.get_logger().error("‚ùå Fallo al soltar")
            return
        
        # 10. Levantar
        node.get_logger().info("--- PASO 10: Retirarse ---")
        if not node.mover_a(PRE_DESTINO[0]-0, PRE_DESTINO[1]+0, PRE_DESTINO[2]-0):
            node.get_logger().error("‚ùå Fallo al retirarse")
            return
        
        # 11. Volver a HOME
        node.get_logger().info("--- PASO 11: Regresar a HOME ---")
        if not node.mover_a(*HOME):
            node.get_logger().error("‚ùå Fallo al regresar")
            return
        node.set_gripper(GRIPPER_HOME)

        node.get_logger().info("=" * 50)
        node.get_logger().info("üéâ ¬°SECUENCIA COMPLETADA EXITOSAMENTE! üéâ")
        node.get_logger().info("=" * 50)

    except KeyboardInterrupt:
        node.get_logger().info("‚ö†Ô∏è Secuencia interrumpida por usuario")
    except Exception as e:
        node.get_logger().error(f"‚ùå Error inesperado: {str(e)}")
    finally:
        node.destroy_node()
        rclpy.shutdown()

# ... (mantener secuencia_2, secuencia_3, secuencia_4 originales si las necesitas)

def main():
    rclpy.init()
    node = Trayectorias()
    
    try:
        # Mantener el nodo vivo esperando se√±ales de presencia
        node.get_logger().info("ü§ñ Sistema listo - Esperando detecci√≥n de presencia...")
        node.get_logger().info("üí° El brazo se activar√° autom√°ticamente cuando se detecte presencia")
        node.get_logger().info("‚èπÔ∏è  Presiona Ctrl+C para salir")
        
        # Usar un executor simple en lugar de rclpy.spin()
        while rclpy.ok():
            rclpy.spin_once(node, timeout_sec=0.1)
            
    except KeyboardInterrupt:
        node.get_logger().info("üëã Programa terminado por usuario")
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == "__main__":
    main()
